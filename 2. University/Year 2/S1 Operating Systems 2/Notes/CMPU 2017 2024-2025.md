## 1
### a)
The four conditions required for Deadlock to occur is,
- Mutual exclusion
- Hold and wait
- Circular wait
- Non Preemptive

### b)
To push a node onto a stack, you will need to first:
Allocate and create a new stack node inside of heap memory, and assign it a value
Then, set the new node (nextPtr) to point to the topPtr node.
After, you set topPtr to the new node.

### c)
Lets say we have a ordered linked list with 3 nodes as such, and we want to add a node with the value 3.
![[Pasted image 20251218232043.png]]

We first create and allocate a ListNode inside of heap memory using malloc, and then check if done successfully
`ListNode* newPtr = malloc(sizeof(ListNode));`
`if (newPtr != NULL) {}`

The value 3 is then assigned to the new node, and a default NULL is assigned as its nextPtr
`newPtr->data = 3; newPtr->nextPtr = NULL;`

Now we create temporary nodes currentPtr and previousPtr
We assign currentPtr to sPtr (the pointer of the address location of the first node in the list), and previousPtr to NULL

We now run a loop that constantly checks if the node value of currentPtr is greater than the value 3. If it is not, it moves previousPtr to currentPtr, and currentPtr to nextPtr. When it finds the spot for the new node, the previousPtr is set to point to the address of the new node. The new node is then set to point at the address of the currentPtr.

If the loop exits out immediately, that means the new node is to be inserted at the beginning. In this case, the new node is set to point at the sPtr, then the sPtr is set to point at the new node.

![[Pasted image 20251218233235.png]]

### d)
#### i.
Lets say we add 2 new nodes to an empty stack. (3 and 7)
When adding a new node of 3, we can see that it successfully allocates a newNode into heap memory. Then, assigns it the value 3, and a temporary nextPtr of NULL. The headPtr and tailPtr is also correctly dereferenced and assigned the address location of the new node.

However when adding another node of value 3, an error occurs. First, it successfully allocates a newNode into heap memory and assigns it the value of 7. Then, it correctly dereferences the tailPtr, changing the nextPtr of node 1, to point to the address location of the new node (node 2). However, there is a mistake when trying to change tailPtr. It is not dereferenced, meaning you are only changing the "copy" of the tailPtr value inside of the add function. This means that the tailPtr inside of the main function does not change. This means that when trying to add any more nodes, the tailPtr will not correctly point to the new node created. 

![[Pasted image 20251219190222.png|500]]

#### ii.
Lets say we have a queue with 3 nodes of these values.
![[Pasted image 20251221151612.png]]
When currentPtr is passed through the printQueue() function, this will be the result.
```c
The queue is: 
3|0x2 (0x1) --> 7|0x2 (0x2) 10|nil (0x3) --> NULL
```

## Question 2
### a)
The process control block (PCB) is used to store information about processes, for process management.
It contains:
- Process ID (PID):
  Unique identifier for each process
- Process State:
  Tracks what the process is currently doing. New, ready, running, waiting, terminated
- Program Counter:
  Holds the address location of the next instruction to be executed
- Accounting Information:
  Holds information about CPU and execution time, for performance monitoring
- Memory management information:
  Information on the process memory limits
- I/O Information:
  Holds list of open files, and input/output devices allocated to the process
### b)
The following code creates a child process. The parent process calls wait(), allowing the child process to increment and print a counter from -5. Upon completion, the parent then increments and prints a counter from 0-5. 

The line `pid_t pid = fork()` uses the fork() command to create a parent child process. In the parent process, the PID of the child value will be returned in the PID variable, whilst the child process will have the value of 0 in the PID variable.
This allows the parent and child process to run different lines of code, due to the `if (pid == 0)` and `else if (pid > 0)`.

In the parent process, it runs the if statement where `pid > 0`. In this statement, it calls the wait() command. This makes the parent process temporarily stop execution, and only continue when the child process has finished. When the child process finished, the wait() command will return the PID of the child process if successful.

In the child process, it runs the if statement where `pid == 0`. It increments and prints a counter from 0-5, showing "child process: counter = 0", "child process: counter = 1" etc.

When the child process finished executing, the parent process will then continue to execute after where the wait() function is called. Therefore, it will increment and print the counter "parent process: counter=0", "parent process: counter-1" etc.

### c)
If the command `./fork 1000 10000` is inputted, then it will cause a delay in the parent and child process.
In the parent process, each time it prints out the value of the counter, it will run a loop where it increments from 0 to 10000.

In the child process, each time it prints out the value of the counter, it will run a loop where it increments from 0 to 1000.

This essentially means that the parent process will take longer to finish executing than the child process

### d)
The execvp() function replaces the current process with a new process, whilst keeping the same PID. The "prog" argument takes in a character pointer (string) of the command you want to replace the current process with. This specific command searched the systems "PATH" environment variable, for the command. The "argv" argument takes in a vector (array of strings") of the commandline arguments you want to bring into the new process. If the function is successful, then every line of code after the "execp()" is replaced and will not run. It does not return or go back to the previous process when it finishes.

If the commandline is "cp file.c file2.c", then:
prog = "cp"
argv = {"cp", "file.c", "file2.c", NULL}

This basically replaces the current process with a process that will run the "cp" command. This will copy "file.c", and paste it as "file2.c".

## Question 3
### a)
Single-threaded processes mean that there is only one thread per process

Multi-threaded processes mean that there are multiple threads per process

Single-threaded processes are easier to code, and does not run into the race problem. However, it can only be used for very simple programs. Multi-threaded processes allows a process to do multiple things at once, as each thread can be given a task. However, it can run into the race problem if threads run in the wrong order

