## 1
### a)
The four conditions required for Deadlock to occur is,
- Mutual exclusion
- Hold and wait
- Circular wait
- Non Preemptive

### b)
To push a node onto a stack, you will need to first:
Allocate and create a new stack node inside of heap memory, and assign it a value
Then, set the new node (nextPtr) to point to the topPtr node.
After, you set topPtr to the new node.

### c)
Lets say we have a ordered linked list with 3 nodes as such, and we want to add a node with the value 3.
![[Pasted image 20251218232043.png]]

We first create and allocate a ListNode inside of heap memory using malloc, and then check if done successfully
`ListNode* newPtr = malloc(sizeof(ListNode));`
`if (newPtr != NULL) {}`

The value 3 is then assigned to the new node, and a default NULL is assigned as its nextPtr
`newPtr->data = 3; newPtr->nextPtr = NULL;`

Now we create temporary nodes currentPtr and previousPtr
We assign currentPtr to sPtr (the pointer of the address location of the first node in the list), and previousPtr to NULL

We now run a loop that constantly checks if the node value of currentPtr is greater than the value 3. If it is not, it moves previousPtr to currentPtr, and currentPtr to nextPtr. When it finds the spot for the new node, the previousPtr is set to point to the address of the new node. The new node is then set to point at the address of the currentPtr.

If the loop exits out immediately, that means the new node is to be inserted at the beginning. In this case, the new node is set to point at the sPtr, then the sPtr is set to point at the new node.

![[Pasted image 20251218233235.png]]

### d)
#### i.
Lets say we add 2 new nodes to an empty stack. (3 and 7)
When adding a new node of 3, we can see that it successfully allocates a newNode into heap memory. Then, assigns it the value 3, and a temporary nextPtr of NULL. The headPtr and tailPtr is also correctly dereferenced and assigned the address location of the new node.

However when adding another node of value 3, an error occurs. First, it successfully allocates a newNode into heap memory and assigns it the value of 7. Then, it correctly dereferences the tailPtr, changing the nextPtr of node 1, to point to the address location of the new node (node 2). However, there is a mistake when trying to change tailPtr. It is not dereferenced, meaning you are only changing the "copy" of the tailPtr value inside of the add function. This means that the tailPtr inside of the main function does not change. This means that when trying to add any more nodes, the tailPtr will not correctly point to the new node created. 

![[Pasted image 20251219190222.png|500]]

#### ii.
Lets say we have a queue with 3 nodes of these values.
![[Pasted image 20251221151612.png]]
When currentPtr is passed through the printQueue() function, this will be the result.
```c
The queue is: 
3|0x2 (0x1) --> 7|0x2 (0x2) 10|nil (0x3) --> NULL
```

## Question 2
### a)
The process control block (PCB) is used to store information about processes, for process management.
It contains:
- Process ID (PID):
  Unique identifier for each process
- Process State:
  Tracks what the process is currently doing. New, ready, running, waiting, terminated
- Program Counter:
  Holds the address location of the next instruction to be executed
- Accounting Information:
  Holds information about CPU and execution time, for performance monitoring
- Memory management information:
  Information on the process memory limits
- I/O Information:
  Holds list of open files, and input/output devices allocated to the process
### b)
The following code uses the fork() command to create a parent child process. When fork() is called from the parent process, it creates a new child process of PID=0. Both the parent and child process then runs concurrently and executing the lines after the fork() command. In the code, return value of fork() is stored into the PID variable.

After, there is a check on the PID. If it is 0 (child process), it runs a loop which increments the counter from 0 to 5. 
If it is not 0 (parent process), it first runs the wait() command. The wait() command takes in the
