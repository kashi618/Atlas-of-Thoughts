## Question 4
### a)
Abstraction focuses on hiding the implementation details, exposing only the essential features. It uses interfaces, to specify "what" to use, without needing to know its implementation.

Meanwhile generalisation focuses on creating a common structure by identifying shared characteristics. It uses inheritance to create child classes that are specialized versions of a parent class. It extracts shared attributes and methods.

### b)
One java construct to illustrate generalisation is by using inheritance. Specifically, the "extends" keyword. This is done by creating a parent child class, where the child class using existing code from the parent, to create a specialized version of the parent.
```java
class Animal {
	String sound = "Animal Noises";
	
	void makeNoise() {
		System.out.println("Animals make " + sound);
	}
}

class Dog extends Animal {
	sound = "Bark";
	
	void makeNoise() {
		System.out.println("Dogs " + sound);
	}
}
```

Another way is by using generics. Generics is used for generalising methods and classes. This means that the same logic can work on unrelated datatypes, without needing a common parent class. 
The class below uses generics to allow you to store one item in the Storage class, regardless of the item's datatype. You can store integers, strings, or whatever inside.
```java
class Storage<T> {
	private T item;
	
	public void add(T item) {
		this.item = item;
	}
	
	public T get(T item) {
		return item;
	}
}
```

### c)
- One benefit for generalisation, is that we can reduce the amount of code to write. We can reuse code, by calling parent child classes.
- Another benefit is to increase maintanability. Reusing code removes the need to write duplicate code. This means that we can create a single source of truth.
  
### d)
Abstraction can create high cohesion and low coupling through use of interfaces. An example of this can be seen in a light switch.
```java
// Abstraction. Interface specifies what methods are required
interface Switchable {
	void turnOn();
}

// High cohesion. The class Lamp has only one job
class Lamp implements Switchable {
	public void turnOn() {
		System.out.println("Light is on !");
	}
}

// Low coupling. Switch is not dependent on Lamp or the other wayt around. It can be used for anything (turn on a class TV instead, or Phone, etc)
class Switch {
	void flip(Switchable thing) {
		thing.turnOn();
	}
}
```

## Question 5
### a)
The UML shows that the Car inherits the Engine. This means that the Car "is an" engine. This is incorrect, as it should be using a composite/aggregate relationship instead. This means that a car "has an" engine.

### b)
![[Pasted image 20260116102052.png]] 

### c)
```java
public class Vehicle {
	String name;
	String email;
	
	Vehicle(String name, String email) {
		this.name = name;
		this.email = email;
	}
	
	void notifyOwner(String message) {
		System.out.println("Sending message to " + name + " using " + email);
		System.out.println(message);
	}
	
	abstract void orderParts(part);
}

public void Car extends Vehicle {
	Car(String name, String email){}
		this.name = name;
		this.email = email;
	}
	
	@Override
	public orderParts(String carPart) {
		System.out.println("Ordering car part: " carPart);
	}
}

public void Motorbike extends Vehicle {
	Motorbike(String name, String email){}
		this.name = name;
		this.email = email;
	}
	
	@Override
	public orderParts(String motorbikePart) {
		System.out.println("Ordering motorbike part: " motorbikePart);
	}
}
```

## Question 6
### a)
First kind is an error. This is when a problem arises within JVM (java virtual machine). An example is when trying multiple objects, causing the system to run out of RAM. This leads to a "OutOfMemoryError"

The second type is a runtime error. This arises from syntax/logic errors in the programs code. It does not need to be defined. An example is when to add a 3rd element to an array with only 2 spaces allocated. This leads to a "NullPointerException"


The third type is an exception. These are manually defined within a program. It is used to catch failures, without needing the program to crash. It uses a "try-catch" block with "throws", so that if an error occurs, it can still continue to run

### b)



### c)
The "finally" clause is used to execute code regardless if an exception is caught or not. It is mainly used to tidy up, such as to close current open files.

Writing the code after the try-catch statement will not work 100% of the time. If an uncaught exception occurs, then the code will not run