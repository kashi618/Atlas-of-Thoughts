Week 8 — Inheritance, Polymorphism, and Core Object Features
-------------------------------------------------------------

### Objectives
- Understand class hierarchies and reuse via inheritance.
- Learn about polymorphism and dynamic binding.
- Explore Object methods (toString, equals, hashCode) and their contracts.
- Practice safe up/downcasting with instanceof.
- Reinforce naming and documentation practices.

### Key Concepts
- Inheritance: A class can extend another class (single inheritance in Java).
  - extends keyword; a subclass inherits fields and methods from its superclass.
- super: Access superclass constructors and methods.
- Method overriding: Subclass provides its own implementation of a superclass method.
- Dynamic binding: The method invoked depends on the actual object type at runtime.
- upcasting: Treating a subclass instance as its superclass type.
- equals and hashCode: Override with care to maintain the contract (consistent with the same class and/or subclass relationships).
- toString: Override for readable object representation.

### Guidelines and Tips
- Favor composition over inheritance when behavior reuse is not hierarchical.
- Keep the superclass small and focused; prefer protected access for enabling controlled subclass interaction.
- When overriding equals, also override hashCode; consider type checks and symmetry.
- Document critical methods with JavaDoc, especially public APIs.

Example: Inheritance, Polymorphism, and equals/hashCode
```java
// Base class
public class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public void speak() {
        System.out.println(name + " makes a sound.");
    }

    @Override
    public String toString() {
        return "Animal{name='" + name + "'}";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Animal)) return false;
        Animal animal = (Animal) o;
        return name != null ? name.equals(animal.name) : animal.name == null;
    }

    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }
}

// Subclass
public class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }

    @Override
    public void speak() {
        System.out.println(name + " says: Woof!");
    }

    @Override
    public String toString() {
        return "Dog{name='" + name + "', breed='" + breed + "'}";
    }

    // equals and hashCode can be extended if needed
}
```

Example usage
```java
public class ZooTest {
    public static void main(String[] args) {
        Animal a = new Dog("Rex", "German Shepherd");
        a.speak(); // dynamic binding -> Dog.speak()

        // Upcasting
        Animal a2 = new Dog("Buddy", "Labrador");
        System.out.println(a2); // uses Dog.toString() if overridden

        // equals/hashCode basics
        Animal a3 = new Animal("Rex");
        System.out.println(a.equals(a3)); // depends on equality logic
    }
}
```

Common Pitfalls
- Overusing inheritance for code reuse can lead to fragile hierarchies; prefer composition when possible.
- Downcasting without instanceof checks can cause ClassCastException.
- Failing to override equals/hashCode consistently can break collections (e.g., HashSet, HashMap).

Week 9 — Interfaces, Abstract Classes, and Functional Interfaces
---------------------------------------------------------------

### Objectives
- Distinguish abstract classes vs. interfaces, and know when to use each.
- Learn about default and static methods in interfaces (Java 8+).
- Introduce functional interfaces, lambdas, and method references.

### Key Concepts
- Abstract class: A class that cannot be instantiated; can have fields, implemented methods, and abstract methods.
- Interface: A contract that a class can implement; from Java 8+, interfaces can have default and static methods.
- Default methods: Interfaces can provide method implementations.
- Functional interface: An interface with a single abstract method, suitable for lambda expressions. Mark with @FunctionalInterface.
- Method references: Use ClassName::methodName as a shorthand for lambdas.

### Guidelines
- Use interfaces to define capabilities (e.g., Comparable, Iterable).
- Use abstract classes to share code among related classes while still enforcing certain methods to be implemented.
- Prefer functional interfaces for behavior that can be passed around (e.g., events, strategies).

### Examples

1) Interface with default method
```java
public interface Shape {
    double area();

    default void describe() {
        System.out.println("This is a shape with area: " + area());
    }
}
```

2) Abstract class and concrete subclasses
```java
public abstract class AbstractShape implements Shape {
    protected String color;

    public AbstractShape(String color) {
        this.color = color;
    }

    public String getColor() { return color; }

    // area() remains abstract to be defined by subclasses
}
```

3) Concrete implementations
```java
public class Circle extends AbstractShape {
    private double radius;

    public Circle(double radius, String color) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle extends AbstractShape {
    private double width, height;

    public Rectangle(double w, double h, String color) {
        super(color);
        this.width = w;
        this.height = h;
    }

    @Override
    public double area() {
        return width * height;
    }
}
```

4) Functional interface and lambda
```java
@FunctionalInterface
public interface Printer {
    void print(String message);
}

// Usage
public class LambdaDemo {
    public static void main(String[] args) {
        Printer p = msg -> System.out.println("Message: " + msg);
        p.print("Hello, world!");

        // Method reference
        Printer p2 = System.out::println;
        p2.print("Using method reference");
    }
}
```

Week 10 — Generics, Collections, and Type-Safe Programming
----------------------------------------------------------

### Objectives
- Master Java generics for type safety and code reuse.
- Learn about the Collections Framework: List, Set, Map, and their common operations.
- Understand wildcards, bounded types, and type erasure basics.
- Practice common collection patterns (iteration, sorting, searching).

### Key Concepts
- Generics: Parameterize types (e.g., List\<T>, Box\<T>).
- Type erasure: Generic type information is erased at runtime; casts may be needed in some scenarios.
- Bounds: Upper bounds (extends), lower bounds (super) for flexibility with wildcards.
- Collections: List (ordered, index-based), Set (unique elements), Map (key-value pairs).
- Iterators and enhanced for loop: Efficient data traversal.
- Sorting: Collections.sort(list) with natural order or Comparator.

### Examples

1) Simple generic class
```java
public class Box<T> {
    private T content;

    public void put(T item) { content = item; }
    public T get() { return content; }
}
```

2) Using generics with collections
```java
import java.util.*;

public class GenericsDemo {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");

        // Type-safe iteration
        for (String n : names) {
            System.out.println(n);
        }

        // Map usage
        Map<String, Integer> ages = new HashMap<>();
        ages.put("Alice", 30);
        ages.put("Bob", 25);

        for (Map.Entry<String, Integer> e : ages.entrySet()) {
            System.out.println(e.getKey() + " is " + e.getValue() + " years old.");
        }
    }
}
```

3) Wildcards and bounds
```java
public class ShapePrinter {
    // Accept any collection of shapes or subtypes
    public static void printAreas(Collection<? extends Shape> shapes) {
        for (Shape s : shapes) {
            System.out.println("Area: " + s.area());
        }
    }
}
```

4) Generic methods
```java
public class Utils {
    // Generic method
    public static <E> void printAll(Collection<E> items) {
        for (E item : items) System.out.println(item);
    }
}
```

Week 11 — Streams, Lambdas Deep Dive, Optional, and I/O
-------------------------------------------------------

### Objectives
- Leverage Java Streams for declarative data processing.
- Deepen understanding of lambdas, method references, and functional style.
- Use Optional to handle absent values explicitly.
- Improve I/O practices with modern patterns (try-with-resources, NIO basics).

### Key Concepts
- Streams: Sequence of elements supporting functional-style operations.
- Laziness and short-circuiting: Intermediates are lazy; terminal operations trigger processing.
- Map, filter, reduce, collect: Core stream operations.
- Optional: A container that may or may not contain a value; avoid nulls.
- Try-with-resources: Automatic resource management for closable resources.
- Basic file I/O: Reading and writing text with BufferedReader/BufferedWriter or PrintWriter.

### Examples

1) Streams with filters, maps, and collects
```java
import java.util.*;
import java.util.stream.*;

public class StreamDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Cathy", "David", "Eve");

        // Filter names longer than 3, uppercase, collect to list
        List<String> result = names.stream()
                                   .filter(n -> n.length() > 3)
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());

        System.out.println(result);
    }
}
```

2) Using Optional
```java
import java.util.Optional;

public class OptionalDemo {
    public static Optional<String> findName(String key) {
        if ("alice".equalsIgnoreCase(key)) {
            return Optional.of("Alice");
        } else {
            return Optional.empty();
        }
    }

    public static void main(String[] args) {
        Optional<String> name = findName("alice");
        name.ifPresent(System.out::println);
        // Or provide a default
        String always = name.orElse("Unknown");
        System.out.println(always);
    }
}
```

3) Streams with collect and grouping
```java
import java.util.*;
import java.util.stream.*;

public class GroupingDemo {
    static class Person {
        String name;
        int age;
        Person(String n, int a){ name = n; age = a; }
        @Override public String toString() { return name + "(" + age + ")"; }
    }

    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Carol", 30)
        );

        Map<Integer, List<String>> agesToNames = people.stream()
            .collect(Collectors.groupingBy(p -> p.age,
                    Collectors.mapping(p -> p.name, Collectors.toList())));

        System.out.println(agesToNames);
    }
}
```

4) Try-with-resources for safe I/O
```java
import java.io.*;

public class FileCopy {
    public static void copyTextFile(String inPath, String outPath) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(inPath));
             PrintWriter out = new PrintWriter(new FileWriter(outPath))) {

            String line;
            while ((line = br.readLine()) != null) {
                out.println(line);
            }
        }
    }

    public static void main(String[] args) {
        try {
            copyTextFile("input.txt", "output.txt");
        } catch (IOException e) {
            System.err.println("IO error: " + e.getMessage());
        }
    }
}
```

## Additional Best Practices and Cross-Cutting Topics
- **JavaDoc and documentation:**
  - Continue using JavaDoc for public APIs; document parameters, return values, and exceptions.
  - For complex methods, include a longer body description with HTML blocks if needed.
- **Coding standards recap:**
  - Naming: class names nouns with uppercase, interfaces nouns/adjectives with uppercase, methods verbs with lowercase, variables camelCase, constants UPPERCASE_WITH_UNDERSCORES.
  - Indentation, braces, and spacing improve readability.
- **Error handling:**
  - Use try-with-resources for I/O.
  - Catch specific exceptions; avoid catching generic Exception unless necessary.
- **Design notes:**
  - Be mindful of composition vs inheritance: prefer composition for flexible reuse.
  - Favor immutability where possible to reduce side effects.
  - Minimize public surface area and document behavior clearly.
- **Practical exercises to reinforce weeks 8–11:**
  - Implement a small hierarchy of shapes (Circle, Rectangle) with area() and a Shape interface. Use a collection to compute total area using streams.
  - Build a simple library system: Book class with equals/hashCode, a Library class using generics and a List\<Book>, search by title with streams.
  - Create a small command-line app that reads a CSV, uses generics to parse records into a List of objects, and prints a summary using streams.
  - Write a class with methods that demonstrate upcasting and downcasting safely with instanceof checks.

## Notes on context alignment
- The notes above extend the OOP and Java-focused topics shown in your Week 6 context: JavaDoc usage, naming conventions, exceptions, primitive vs. reference types, file I/O, and general coding principles.
- If your course has a preferred ordering or additional topics (e.g., Java NIO, advanced generics, or design patterns), you can slot those into Weeks 10–11 as needed.
