---
tags:
  - OS2
aliases:
---
## 1
### a)
The four conditions required for Deadlock to occur is,
- Mutual exclusion
- Hold and wait
- Circular wait
- Non Preemptive

### b)
To push a node onto a stack, you will need to first:
Allocate and create a new stack node inside of heap memory, and assign it a value
Then, set the new node (nextPtr) to point to the topPtr node.
After, you set topPtr to the new node.

### c)
Lets say we have a ordered linked list with 3 nodes as such, and we want to add a node with the value 3.
![[Pasted image 20251218232043.png]]

We first create and allocate a ListNode inside of heap memory using malloc, and then check if done successfully
`ListNode* newPtr = malloc(sizeof(ListNode));`
`if (newPtr != NULL) {}`

The value 3 is then assigned to the new node, and a default NULL is assigned as its nextPtr
`newPtr->data = 3; newPtr->nextPtr = NULL;`

Now we create temporary nodes currentPtr and previousPtr
We assign currentPtr to sPtr (the pointer of the address location of the first node in the list), and previousPtr to NULL

We now run a loop that constantly checks if the node value of currentPtr is greater than the value 3. If it is not, it moves previousPtr to currentPtr, and currentPtr to nextPtr. When it finds the spot for the new node, the previousPtr is set to point to the address of the new node. The new node is then set to point at the address of the currentPtr.

If the loop exits out immediately, that means the new node is to be inserted at the beginning. In this case, the new node is set to point at the sPtr, then the sPtr is set to point at the new node.

![[Pasted image 20251218233235.png]]

### d)
#### i.
Lets say we add 2 new nodes to an empty stack. (3 and 7)
When adding a new node of 3, we can see that it successfully allocates a newNode into heap memory. Then, assigns it the value 3, and a temporary nextPtr of NULL. The headPtr and tailPtr is also correctly dereferenced and assigned the address location of the new node.

However when adding another node of value 3, an error occurs. First, it successfully allocates a newNode into heap memory and assigns it the value of 7. Then, it correctly dereferences the tailPtr, changing the nextPtr of node 1, to point to the address location of the new node (node 2). However, there is a mistake when trying to change tailPtr. It is not dereferenced, meaning you are only changing the "copy" of the tailPtr value inside of the add function. This means that the tailPtr inside of the main function does not change. This means that when trying to add any more nodes, the tailPtr will not correctly point to the new node created. 

![[Pasted image 20251219190222.png|500]]

#### ii.


# See Also
[[$ Operating Systems 2]]
[[CMPU 2017 2024-2025| 2024-2025.pdf]]