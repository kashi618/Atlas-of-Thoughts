/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const DEFAULT_SETTINGS = {
    selectionSeperator: ",",
    characterSeperator: ":",
    keepCharacterLocation: true,
    keepPrimarySelection: true,
    selectHead: true,
    newlineAtEndOfDoc: false,
};
class GoToLinePlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("loading 'Go To Line' plugin");
            this.addCommand({
                id: "go-to-line",
                name: "Go to line",
                editorCallback: (editor) => {
                    new GotoModal(this.app, editor, this).open();
                },
            });
            this.addCommand({
                id: "go-to-line-auto",
                name: "Go to line with clipboard contents",
                editorCallback: (editor) => this.goToLineAuto(editor),
            });
            this.addCommand({
                id: "cursor-location-copy",
                name: "Copy cursor line number",
                editorCallback: (editor) => this.copyLineNumbers(editor),
            });
            this.addCommand({
                id: "cursor-location-copy-all",
                name: "Copy all cursor line numbers",
                editorCallback: (editor) => this.copyAllLineNumbers(editor),
            });
            yield this.loadSettings();
            this.addSettingTab(new GoToLineSettingTab(this.app, this));
        });
    }
    onunload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("unloading 'Go To Line' plugin");
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("loading Settings");
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("saving Settings");
            yield this.saveData(this.settings);
        });
    }
    getLocation(cursor) {
        return this.settings.keepCharacterLocation
            ? `${cursor.line + 1}${this.settings.characterSeperator}${cursor.ch}`
            : (cursor.line + 1).toString();
    }
    parseLocations(str) {
        const lines = str.split(this.settings.selectionSeperator);
        const locations = lines.map((line) => {
            const anchor = this.parseLocation(line);
            return anchor ? { anchor } : null;
        });
        return locations.filter((ln) => ln);
    }
    parseLocation(loc) {
        const trimmed = loc.trim();
        if (!trimmed) {
            return null;
        }
        const data = trimmed.split(this.settings.characterSeperator);
        let line = Number(data[0].trim()) - 1;
        let ch = 0;
        if (data.length > 1) {
            ch = Number(data[1].trim());
        }
        if (isNaN(line) || isNaN(ch)) {
            return null;
        }
        return { line, ch };
    }
    getCursor(editor) {
        return this.settings.selectHead
            ? editor.getCursor("head")
            : editor.getCursor("anchor");
    }
    copyLineNumbers(editor) {
        return __awaiter(this, void 0, void 0, function* () {
            if (editor) {
                const cursor = this.getCursor(editor);
                const location = this.getLocation(cursor);
                yield navigator.clipboard.writeText(location);
            }
        });
    }
    copyAllLineNumbers(editor) {
        return __awaiter(this, void 0, void 0, function* () {
            if (editor) {
                let lines = editor.listSelections().map((selection) => {
                    const cursor = this.settings.selectHead ? selection.head : selection.anchor;
                    return { line: cursor.line, ch: cursor.ch };
                });
                if (this.settings.keepPrimarySelection) {
                    const primary = this.getCursor(editor);
                    const primary_index = lines.findIndex((pos) => {
                        return pos.line == primary.line && pos.ch == primary.ch;
                    });
                    lines.splice(primary_index, 1);
                    lines.push(primary);
                }
                const eachLine = lines.map((line) => this.getLocation(line));
                const locations = eachLine.join(this.settings.selectionSeperator);
                yield navigator.clipboard.writeText(locations);
            }
        });
    }
    goToLine(editor, operations) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.settings.newlineAtEndOfDoc) {
                const lastLine = editor.lastLine();
                const pastEnd = operations.find(op => op.anchor.line > lastLine);
                if (pastEnd != undefined) {
                    const lastChar = editor.getLine(lastLine).length;
                    editor.setSelection({ line: lastLine, ch: lastChar });
                    editor.exec("newlineAndIndent");
                }
            }
            editor.setSelections(operations);
        });
    }
    goToLineAuto(editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const str = yield navigator.clipboard.readText();
            const operations = this.parseLocations(str);
            if (!operations.length) {
                new obsidian.Notice("Go To Line: Clipboard does not contain valid line information", 5000);
            }
            for (const op of operations) {
                if (op.anchor.line < 0 || op.anchor.ch < 0) {
                    new obsidian.Notice(("Cannot go to negative line or character locations: " +
                        `${this.getLocation(op.anchor)}`), 5000);
                    return null;
                }
            }
            yield this.goToLine(editor, operations);
        });
    }
}
/* I am using a SuggestModal here, because I wanted to
replicate the Design of the Input Field at the top.
This was seemingly the easiest way to do it.  */
class GotoModal extends obsidian.SuggestModal {
    constructor(app, editor, plugin) {
        super(app);
        this.editor = editor;
        this.plugin = plugin;
        this.modalEl.addClass("GTL-modal");
        this.inputEl.placeholder = `Line Number between 1 and ${editor.lineCount()}`;
    }
    getSuggestions(str) {
        if (str) {
            const operations = this.plugin.parseLocations(str);
            for (const op of operations) {
                if (op.anchor.line < 0 || op.anchor.ch < 0) {
                    this.inputEl.addClass("is-invalid");
                    return [];
                }
            }
            this.inputEl.removeClass("is-invalid");
            return [operations];
        }
        this.inputEl.removeClass("is-invalid");
        return [];
    }
    renderSuggestion(_, __) {
        return;
    }
    onChooseSuggestion(operations, _) {
        this.plugin.goToLine(this.editor, operations);
    }
}
class GoToLineSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    resetComponent(elem, setting) {
        const value = DEFAULT_SETTINGS[setting];
        const nameEl = elem.settingEl.parentElement.childNodes[0];
        console.log(`resetting '${nameEl.innerText}' to '${value}'`);
        let component = elem.components[0];
        component.setValue(value);
        this.plugin.settings[setting] = DEFAULT_SETTINGS[setting];
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        let selectionSeperatorEl = containerEl.createDiv();
        selectionSeperatorEl.createEl("h3", { text: "Selection Seperator" });
        let selectionSeperator = new obsidian.Setting(selectionSeperatorEl)
            .setName("String to seperate multiple curor locations.")
            .addText((text) => {
            text.setValue(this.plugin.settings.selectionSeperator)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                console.log(`changing selectionSeperator to ${value}`);
                this.plugin.settings.selectionSeperator = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(selectionSeperatorEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.selectionSeperator}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(selectionSeperator, "selectionSeperator");
            yield this.plugin.saveSettings();
        })));
        let characterSeperatorEl = containerEl.createDiv();
        characterSeperatorEl.createEl("h3", { text: "Character Seperator" });
        let characterSeperator = new obsidian.Setting(characterSeperatorEl)
            .setName("Line number and character number seperator")
            .addText((text) => {
            text.setValue(this.plugin.settings.characterSeperator)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                console.log(`changing characterSeperator to ${value}`);
                this.plugin.settings.characterSeperator = value;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(characterSeperatorEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.characterSeperator}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(characterSeperator, "characterSeperator");
            yield this.plugin.saveSettings();
        })));
        let keepCharacterLocationEl = containerEl.createDiv();
        keepCharacterLocationEl.createEl("h3", { text: "Keep Character Location" });
        let keepCharacterLocation = new obsidian.Setting(keepCharacterLocationEl)
            .setName("Copy the character location of the cursor when copying.")
            .addToggle((cb) => cb.setValue(this.plugin.settings.keepCharacterLocation != null
            ? this.plugin.settings.keepCharacterLocation
            : DEFAULT_SETTINGS.keepCharacterLocation)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings.keepCharacterLocation != value) {
                console.log(`changing keepCharacterLocation to ${value}`);
            }
            this.plugin.settings.keepCharacterLocation = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(keepCharacterLocationEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.keepCharacterLocation}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(keepCharacterLocation, "keepCharacterLocation");
            yield this.plugin.saveSettings();
        })));
        let keepPrimarySelectionEl = containerEl.createDiv();
        keepPrimarySelectionEl.createEl("h3", { text: "Keep Primary Cursor on Mulitple Copy" });
        let keepPrimarySelection = new obsidian.Setting(keepPrimarySelectionEl)
            .setName("Keeps primary cursor at the end of location list when copies. \
				If disabled, primary cursor will become the cursor furthest down document.")
            .addToggle((cb) => cb.setValue(this.plugin.settings.keepPrimarySelection != null
            ? this.plugin.settings.keepPrimarySelection
            : DEFAULT_SETTINGS.keepPrimarySelection)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings.keepPrimarySelection != value) {
                console.log(`changing keepPrimarySelection to ${value}`);
            }
            this.plugin.settings.keepPrimarySelection = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(keepPrimarySelectionEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.keepPrimarySelection}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(keepPrimarySelection, "keepPrimarySelection");
            yield this.plugin.saveSettings();
        })));
        let selectHeadEl = containerEl.createDiv();
        selectHeadEl.createEl("h3", { text: "Get Head of Cursor" });
        let selectHead = new obsidian.Setting(selectHeadEl)
            .setName("Get the location of the head of a selection when copying line number. \
				If disabled the anchor will be copied.")
            .addToggle((cb) => cb.setValue(this.plugin.settings.selectHead != null
            ? this.plugin.settings.selectHead
            : DEFAULT_SETTINGS.selectHead)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings.selectHead != value) {
                console.log(`changing selectHead to ${value}`);
            }
            this.plugin.settings.selectHead = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(selectHeadEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.selectHead}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(selectHead, "selectHead");
            yield this.plugin.saveSettings();
        })));
        let newlineAtEndOfDocEl = containerEl.createDiv();
        newlineAtEndOfDocEl.createEl("h3", { text: "Create Newline At End Of Document" });
        let newlineAtEndOfDoc = new obsidian.Setting(newlineAtEndOfDocEl)
            .setName("Create a newline at the end of the document if given \
				line number is past the end. Multiple lines past the end \
				will only create one extra line.")
            .addToggle((cb) => cb.setValue(this.plugin.settings.newlineAtEndOfDoc != null
            ? this.plugin.settings.newlineAtEndOfDoc
            : DEFAULT_SETTINGS.newlineAtEndOfDoc).onChange((value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings.newlineAtEndOfDoc != value) {
                console.log(`changing newlineAtEndOfDoc to ${value}`);
            }
            this.plugin.settings.newlineAtEndOfDoc = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(newlineAtEndOfDocEl)
            .setName(`Reset to default value of '${DEFAULT_SETTINGS.newlineAtEndOfDoc}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent(newlineAtEndOfDoc, "newlineAtEndOfDoc");
            yield this.plugin.saveSettings();
        })));
        containerEl.createDiv().createEl("h2", { text: "Reset All Settings" });
        const GoToLineSettings = [
            { elem: selectionSeperator, setting: "selectionSeperator" },
            { elem: characterSeperator, setting: "characterSeperator" },
            { elem: keepCharacterLocation, setting: "keepCharacterLocation" },
            { elem: keepPrimarySelection, setting: "keepPrimarySelection" },
            { elem: selectHead, setting: "selectHead" },
            { elem: newlineAtEndOfDoc, setting: "newlineAtEndOfDoc" },
        ];
        let resetAllEl = containerEl.createDiv();
        new obsidian.Setting(resetAllEl)
            .setName("Reset all settings to default values. \
				(Don't forget about the hotkeys! Just search 'Go To Line' \
				to find the 3 commands.)")
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            console.log("resetting all values to their defaults.");
            GoToLineSettings.forEach((setting) => this.resetComponent(setting.elem, setting.setting));
            yield this.plugin.saveSettings();
        })));
    }
}

module.exports = GoToLinePlugin;


/* nosourcemap */